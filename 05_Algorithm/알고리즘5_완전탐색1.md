# 브루트포스 (Brute-force, 무식하게 풀기)
> 모든 경우의 수를 탐색하여 문제를 해결하는 방식
> 가장 단순한 풀이 기법으로, 단순 조건문과 반복문을 이용해서 풀 수 있다.
> 복잡한 알고리즘 보다는, 아이디어를 어떻게 코드로 구현할 것인지가 중요하다.

## 예제로 알아보기
### [BOJ 2798: 블랙잭](https://www.acmicpc.net/problem/2798)
- 문제
        N장의 카드 중에서 3장의 카드를 골랐을 때 카드의 합이 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.
- 입력
        첫째 줄에 카드의 개수 N과 M이 주어진다. (3 ≤ N ≤ 100, 10 ≤ M ≤ 300,000)
        둘째 줄에는 카드에 쓰여 있는 수가 주어진다. 이 값은 100,000을 넘지 않는 양의 정수이다.
        합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.
- 출력
        첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.
---
- 풀이
![브루트포스블랙잭.jpg](./img\브루트포스블랙잭.jpg)

```python
n, m = map(int, input().split())
card = list(map(int, input().split()))
max_sum = 0
for i in range(n - 2):
    for j in range(i + 1, n - 1):
        for k in range(j + 1, n):
            sum_ = card[i] + card[j] + card[k]
            if sum_ > max_sum and sum_ <= m:
                max_sum = sum_
            
            if max_sum == m:
                break
print(max_sum)
```


# 델타 탐색 (Delta Search)
> 이차원 리스트의 완전탐색에서 많이 등장하는 유형
> (0, 0)에서부터 이차원 리스트의 모든 원소를 순회하며 (완전탐색) **각 지점에서 상하좌우에 위치한 다른 지점을 조회하거나 이동**하는 방식이다.
> 이차원 리스트의 인덱스(좌표)의 조작을 통해서 상하좌우 탐색을 한다.
> 이때 행과 열의 변량인 -1, +1을 **델타(delta)값**이라 한다.
![델타탐색.png](./img\델타탐색.png "델타탐색.png")

## 델타값을 이용해 상하좌우 이동하기
> 행은 x 혹은 r, 열은 y 혹은 c로 나타낸다
```python
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```
> 참고로 dx, dy를 튜플로 묶은 리스트를 이용할 수도 있다.
```python
delta = [(-1, 0), (1, 0), (0, -1), (0, 1)]
```
> 델타값을 이용해 상하좌우 이동하기
```python
# 상(x-1, y)
nx = x + dx[0]
ny = y + dy[0]

# 하(x+1, y)
nx = x + dx[1]
ny = y + dy[1]

# 좌(x, y-1)
nx = x + dx[2]
ny = y + dy[2]

# 우(x, y+1)
nx = x + dx[3]
ny = y + dy[3]
```
```python
for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]
```
> 상하좌우로 이동 후 범위를 벗어나지 않는지 확인하고 갱신하기!
![델타탐색_범위설정.png](./img\델타탐색_범위설정.png)

```python
# 델타값을 이용해 상하좌우 이동
for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]
    
    # 범위를 벗어나지 않으면 갱신
    if 0 <= nx < 3 and 0 <= ny < 3:
        x = nx
        y = ny
```

## 이차원 리스트의 상하좌우 탐색 정리
1. 델타값 정의
2. 이차원 리스트 순회
3. 델타값을 이용해 상하좌우 이동
4. 범위를 벗어나지 않으면 갱신
```python
# 1. 델타값 정의(상하좌우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 2. 이차원 리스트 순회
for x in range(n):
    for y in range(m):
        
        # 3. 델타값을 이용해 상하좌우 이동
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            # 4. 범위를 벗어나지 않으면 갱신
            if 0 <= nx < n and 0 <= ny < m:
                x = nx
                y = ny
```

## 상하좌우 + 대각선의 8방향 델타값
```python
# 상, 하, 좌, 우 좌상, 좌하, 우상, 우하
dx = [-1, 1, 0, 0, -1, 1, -1, 1]
dy = [0, 0, -1, 1, -1, -1, 1, 1]
```
![8방향델타탐색.png](./img\8방향델타탐색.png)