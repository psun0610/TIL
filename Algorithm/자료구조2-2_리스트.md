# 배열 vs 연결 리스트
- ***배열 (Array)***
    > **여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조**
    - 인덱스를 통해 데이터에 빠르게 접근할 수 있음
    - 배열의 길이는 변경이 불가능하므로 길이를 변경하고 싶다면 새로 생성하여야 함
    - 데이터 타입은 고정임

- ***연결 리스트 (Linked List)***
    > **데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조**
    - 맨 처음 노드부터 순차적으로 탐색
    - 연결리스트의 길이는 자유롭게 변경 가능하여 삽입, 삭제가 편리함
    - 다양한 데이터 타입을 저장할 수 있음
    - 데이터가 메모리에 연속적으로 저장되지 않음

> 배열의 *인덱스 접근 방식*과 연결 리스트의 *가변 길이*의 장점을 모두 합친 것이 바로 **파이썬의 리스트**

# 파이썬의 리스트
## 메소드
1. `.append(원소)`
    - 리스트 맨 끝에 새로운 원소 삽입
2. `.pop(인덱스)`
    - 특정 인덱스에 있는 원소를 삭제 및 반환
3. `.count(원소)`
    - 리스트에서 해당 원소의 개수를 반환
4. `.index(원소)`
    - 리스트에서 처음으로 원소가 등장하는 인덱스 반환
5. `.sort()
    - 리스트를 오름차순으로 정렬
    - `reverse=True` 옵션을 통해 내림차순으로도 정렬 가능
6. `.reverse()`
    - 리스트의 원소들의 순서를 거꾸로 뒤집기

## 자주 쓰이는 내장 함수
1. `len(iterable)`
    - 리스트의 길이(원소의 개수)를 반환
2. `sum(iterable)`
    - 리스트의 모든 원소의 합을 반환
3. `max(iterable)`
    - 리스트의 원소 중 최대값을 반환
4. `min(iterable)`
    - 리스트의 원소 중 최소값을 반환
5. `sorted(iterable)`
    - 오름차순으로 정렬된 새로운 리스트 반환
    - 원본 리스트는 변화 없음
6. `reversed(iterable)`
    - 리스트의 순서를 거꾸로 뒤집은 새로운 객체 반환
    - 원본 리스트는 변화 없음

# 리스트 컴프리헨션
> 코드 한 줄만으로 새로운 리스트를 만드는 방법
- 원래 코드
```python
numbers = []
for i in range(5):
    numbers.append(i)
```
- 리스트 컴프리헨션 사용
```python
numbers = [i for i in range(5)]
```
- if문으로 필터링도 가능
```python
odd_numbers = [i for i in range(10) if i % 2 == 1]
```

1. 리스트 컴프리헨션 연습 1
> 문제: 정수 n을 입력받아, 1부터 n까지의 제곱수를 리스트로 만들어 출력하는 프로그램을 작성하라
```python
n = int(input())
numbers = [i**2 for i in range(1, n+1)]
print(numbers)
```
2. 리스트 컴프리헨션 연습 2
> 문제: 리스트 내포를 이용하여 1번부터 입력받은 숫자까지의 숫자에 "No."를 붙인 문자열을 원소로 하는 리스트를 만들어 출력하라
```python
n = int(input())
numbers = ["No."+ str(i) for i in range(1, n+1)]
print(numbers)
```
3. 리스트 컴프리헨션 연습 3 [(BOJ 2562)](https://www.acmicpc.net/problem/2562)
> 문제: 9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오
```python
numbers = [int(input()) for i in range(9)\]
max_ = max(numbers)
index_ = numbers.index(max_) + 1
print(max_, index_, sep='\\n')
```