# 그리디 알고리즘 (탐욕법)

> 현재 지금 당장 좋은 것만 고르는 방법

그리디 알고리즘은 매 순간 가장 좋은 것만 선택하며, **현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.**

&nbsp;

## 예제 1

> ### 문제
>
> 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리의 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

동전의 최소 개수를 구하기 위해서는 **가장 큰 화폐 단위부터 가장 많이 돈을 거슬러 줘야 한다.**

```python
n = int(input())
cnt = 0		# answer
coin_types = [500, 100, 50, 10]		# 화폐 단위는 가장 큰 500원부터 차례대로

for coin in coin_types:
    cnt += n // coin	# 해당 화폐로 거슬러 줄 수 있는 동전의 개수
    n %= coin	# 큰 화폐단위부터 거슬러 주고 남은 돈
   
print(cnt)
```

&nbsp;

> ### 논의

위 문제가 그리디 알고리즘으로 풀리는 이유는 가지고 있는 동전의 단위가 모두 배수의 형태이기 때문이다. 작은 단위의 동전을 종합해 다른 해가 나올 수 없으므로 그리디가 언제나 최적해를 보장한다.

하지만 문제에서 단위가 서로 배수의 형태가 아니라, 무작위로 주어지는 경우에는 **다이나믹 프로그래밍**으로 해결해야 한다.

&nbsp;

## 그리디 알고리즘의 정당성

그리디 알고리즘으로 최적의 해를 구할 수 있는지 검토하는 것이 정말 중요하다.

거스름돈 문제에서는 '*가장 큰 화폐 단위부터'* 돈을 거슬러 주어야 했기 때문에 단순히 가장 큰 것만 찾는다고 했을 때도 정확한 답을 찾을 수 있었다.

&nbsp;

그리디 알고리즘으로 최적해를 도출하기 위해서는 아래 두 조건을 만족해야 한다.

### 1. 탐욕적 선택 속성 (greedy choice property)

탐욕적인 선택이 항상 안전하다는 것이 보장된다는 의미이다.

즉, 그리디한 선택이 언제나 최적해를 보장해야 한다.

### 2. 최적 부분 구조 (optimal substructure)

부분 최적해(Local optimum)들이 모여 전체 최적해(Global optimum)를 구할 수 있는 경우이다.

**전체 문제가 여러 부분 문제로 분할**되며, 이 단계 **하나하나에 대한 최적해가 도출되어야 한다**는 의미이다.

![image](https://user-images.githubusercontent.com/97274144/228278305-7f0cc887-f930-42bd-9dbd-51d5521cb723.png)

예를 들어 위 그림처럼 도시 간 이동을 할 때  서울-대전의 최단 경로와 대전-부산의 최단 경로가 모여서 서울-부산의 최단 경로가 된다.