# DP 동적 계획법 (Dynamic Programming)

> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법

**부분 문제 반복**과 **최적 부분 구조**를 가지고 있는 알고리즘에 사용

=> 부분 문제의 해는 전체 문제의 해를 구할 때 필요해야 함

=> 최적성의 원리가 적용됨을 확인했으면 주어진 문제를 소문제로 분해하여 최적해를 제공하는 점화식을 도출해야 함

&nbsp;

- 분할 정복과의 차이점
  - 분할 정복은 소문제가 독립적이고, 동적 계획법은 소문제가 독립적이지 않음
  - 동적 계획법 적용이 가능한 문제는 소문제가 상위 문제에 사용됨
- 탐욕법과의 차이점
  - 탐욕법은 현재 상태에서의 가장 최적의 경우를 판단하기 때문에 문제에 따라 최적해를 구할 수 없을 수도 있음
  - 동적 계획법은 모든 가능성을 고려하므로 항상 최적의 결과가 도출됨

&nbsp;

## 하향식 (Top-Down, 메모이제이션(Memoization))

> 한번 계산한 결과를 메모리 공간에 메모하는 기법

재귀적인 방법으로 사용함, 하위 문제 정답을 계산했는지 확인하며 안 했으면 재귀 호출

```python
# 피보나치 하향식 계산
dp = [0] * 100 # 소문제 결과를 저장할 리스트
dp[0] = 1
dp[1] = 1

def fibo(n):
    # 만약 계산한 적이 없다면 재귀로 계산
    if dp[n] == 0:
        dp[n] = fibo(n-1) + fibo(n-2)
    # 있다면 그대로 반환
    return dp[n]

fibo(10)
```



## 상향식 (Bottom-Up)

> 더 작은 하위 문제부터 살펴본 다음 작은 문제의 정답을 이용하여 큰 문제의 정답을 풀어나가는 방법

반복문을 사용하여 작은 문제부터 계산하며 진행함

```python
# 피보나치 상향식 계산
def fibo(n):
    dp = [0] * (n+1)
    dp[0] = 1
    dp[1] = 1
    
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

fibo(10)
```

